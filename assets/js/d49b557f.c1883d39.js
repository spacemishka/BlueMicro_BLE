"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[2511],{3905:function(e,n,t){t.d(n,{Zo:function(){return s},kt:function(){return y}});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var d=a.createContext({}),c=function(e){var n=a.useContext(d),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},s=function(e){var n=c(e.components);return a.createElement(d.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},u=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,d=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),u=c(t),y=r,f=u["".concat(d,".").concat(y)]||u[y]||p[y]||o;return t?a.createElement(f,i(i({ref:n},s),{},{components:t})):a.createElement(f,i({ref:n},s))}));function y(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=u;var l={};for(var d in n)hasOwnProperty.call(n,d)&&(l[d]=n[d]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var c=2;c<o;c++)i[c]=t[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},7553:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return l},contentTitle:function(){return d},metadata:function(){return c},toc:function(){return s},default:function(){return u}});var a=t(7462),r=t(3366),o=(t(7294),t(3905)),i=["components"],l={id:"configure_keymap",title:"Configuring keymap.h.cpp",slug:"/configure_keymap"},d=void 0,c={unversionedId:"configure_keymap",id:"configure_keymap",title:"Configuring keymap.h.cpp",description:"Configuring your keyboard - Part 3: Keymap Definition",source:"@site/docs/configuring_firmware_3.md",sourceDirName:".",slug:"/configure_keymap",permalink:"/docs/configure_keymap",editUrl:"https://github.com/jpconstantineau/BlueMicro_BLE/tree/documentation-docusaurus/documentation/docs/configuring_firmware_3.md",tags:[],version:"current",frontMatter:{id:"configure_keymap",title:"Configuring keymap.h.cpp",slug:"/configure_keymap"},sidebar:"someSidebar",previous:{title:"Configuring keyboard_config.h",permalink:"/docs/configure_keyboard"},next:{title:"Configuring Advanced Features",permalink:"/docs/configure_combos"}},s=[{value:"Configuring your keyboard - Part 3: Keymap Definition",id:"configuring-your-keyboard---part-3-keymap-definition",children:[{value:"The default layer",id:"the-default-layer",children:[],level:3},{value:"Further layers",id:"further-layers",children:[],level:3},{value:"Rotary Encoder Definition (1 encoder)",id:"rotary-encoder-definition-1-encoder",children:[],level:3},{value:"Rotary Encoder Definition (Up to 8 encoders)",id:"rotary-encoder-definition-up-to-8-encoders",children:[],level:3},{value:"OLED Definition",id:"oled-definition",children:[],level:3},{value:"Speaker/Buzzer/Audio Definition",id:"speakerbuzzeraudio-definition",children:[],level:3}],level:2}],p={toc:s};function u(e){var n=e.components,t=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"configuring-your-keyboard---part-3-keymap-definition"},"Configuring your keyboard - Part 3: Keymap Definition"),(0,o.kt)("h3",{id:"the-default-layer"},"The default layer"),(0,o.kt)("p",null,'The default layer is the layer which you will most often use. Generally this is the "QWERTY" Layer.\nFor example for the gherkin 3x10:'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c++"},"std::array<std::array<Key, MATRIX_COLS>, MATRIX_ROWS> matrix =\n    KEYMAP2ARRAY(KEYMAP(\n        KC_Q,    KC_W,    KC_E,    KC_R,    KC_T,    KC_Y,    KC_U,    KC_I,    KC_O,    KC_P,\n        KC_A,    KC_S,    KC_D,    KC_F,    KC_G,    KC_H,    KC_J,    KC_K,    KC_L,    KC_ESC,\n        KC_Z,    KC_X,    KC_C,    KC_V,    KC_SPC,  KC_BKSPC,KC_B,    KC_N,    KC_M,    KC_NO \n        ));\n        \n")),(0,o.kt)("p",null,"Notice the 2 macros being used: ",(0,o.kt)("inlineCode",{parentName:"p"},"KEYMAP2ARRAY")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"KEYMAP"),". Since the ",(0,o.kt)("inlineCode",{parentName:"p"},"matrix")," variable is a c++ array, we need to convert the output of the ",(0,o.kt)("inlineCode",{parentName:"p"},"KEYMAP")," macro from a C array to a c ++ array. "),(0,o.kt)("h3",{id:"further-layers"},"Further layers"),(0,o.kt)("p",null,"For additional layers, you will need to programatically add the layers and the keycodes.  This is done in the function ",(0,o.kt)("inlineCode",{parentName:"p"},"setupKeymap()"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c++"},"void setupKeymap() {\n\n    uint32_t layer1[MATRIX_ROWS][MATRIX_COLS] =\n        KEYMAP(\n    KC_NO,    KC_NO,    KC_NO,    KC_NO,    KC_NO,     KC_NO,    KC_NO,    KC_NO,    KC_NO,    KC_NO,\n    KC_NO,    KC_NO,    KC_NO,    KC_NO,    KC_NO,     KC_NO,    KC_NO,    KC_NO,    KC_NO,    KC_NO,\n    KC_Z,     KC_X,     KC_C,     KC_V,     KC_SPC,    KC_BSPC,  KC_B,     KC_N,     KC_M,     KC_ENT );\n\n    ADDLAYER(_L1, Method::PRESS , layer1);\n\n}\n\n")),(0,o.kt)("p",null,"Notice that in the ",(0,o.kt)("inlineCode",{parentName:"p"},"setupKeymap()")," function, we use c arrays that only need the ",(0,o.kt)("inlineCode",{parentName:"p"},"KEYMAP2ARRAY")," macro to help you with your keymap."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"ADDLAYER")," macro simplifies the process of adding your layer and has the following arguments:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"LAYER NUMBER"),": The first argument is the layer number.  Unlike the layer keycode, this is a simple number from 0 to 6 (up to 15 may be supported; depending on memory availability and matrix size)."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"ACTIVATION METHOD"),": Generally, you will use the ",(0,o.kt)("inlineCode",{parentName:"li"},"Method::PRESS")," method. Other methods are ",(0,o.kt)("inlineCode",{parentName:"li"},"Method::MT_TAP"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"Method::MT_HOLD"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"Method::DT_TAP")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"Method::DT_DOUBLETAP"),'. If a key keys triggered using multiple methods, all methods will "fire" and send a keycode.  As such, it\'s useful to use the ',(0,o.kt)("inlineCode",{parentName:"li"},"KC_NO")," keycode to avoid sending anything for a specific activation."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"KEYMAP ARRAY"),": This is the C array to load.")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"ADDLAYER")," macro wraps the Key::addActivation with a loop for all rows and columns of the key matrix. "),(0,o.kt)("p",null,"Note that when using ",(0,o.kt)("inlineCode",{parentName:"p"},"KC_NO")," as the keycode within a layer, the firmware will automatically bypass this keycode for this specific key and it won't be added to its mapping.  As such, having lots of ",(0,o.kt)("inlineCode",{parentName:"p"},"KC_NO")," keycodes in a layer won't affect the performance of the keyboard."),(0,o.kt)("h3",{id:"rotary-encoder-definition-1-encoder"},"Rotary Encoder Definition (1 encoder)"),(0,o.kt)("p",null,"You can refer to the configuration of the solfle keyboard - default configuration for a working example for a single encoder."),(0,o.kt)("p",null," This configuration uses the hardware QDEC peripheral (Quadrature Decoder) that's part of the nRF52 SoC and uses callbacks to handle rotation."),(0,o.kt)("p",null,"You will need to add a few things to your keymap.h file."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c++"},'#include "KeyScanner.h"  // include at the top with the other includes\nextern DynamicState keyboardstate;\nvoid encoder_callback(int step); // add right after void setupKeymap();\n\n')),(0,o.kt)("p",null,"You will also need to add a few things to your keymap.cpp file.  For example, you will need to add the following 3 lines in the ",(0,o.kt)("inlineCode",{parentName:"p"},"setupKeymap()")," function:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c++"},"// Code below makes sure that the encoder gets configured.\n\n  RotaryEncoder.begin(ENCODER_PAD_A, ENCODER_PAD_B);    // Initialize Encoder\n  RotaryEncoder.setCallback(encoder_callback);    // Set callback\n  RotaryEncoder.start();    // Start encoder\n\n")),(0,o.kt)("p",null,"You will need to add the  ",(0,o.kt)("inlineCode",{parentName:"p"},"encoder_callback()")," function:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c++"},"void encoder_callback(int step)\n{\n  uint8_t layer = keyboardstate.layer;\n  if ( step > 0 )\n  {\n      switch(layer)\n      {\n          case _L0: KeyScanner::add_to_encoderKeys(KC_AUDIO_VOL_UP); break;\n          case _L1: KeyScanner::add_to_encoderKeys(KC_RIGHT); break;\n          case _L2: KeyScanner::add_to_encoderKeys(LSFT(KC_RIGHT)); break;\n          default: ;\n      }\n  }else\n  {\n      switch(layer)\n      {\n          case _L0: KeyScanner::add_to_encoderKeys(KC_AUDIO_VOL_DOWN); break;\n          case _L1: KeyScanner::add_to_encoderKeys(KC_LEFT);break;\n          case _L2: KeyScanner::add_to_encoderKeys(LSFT(KC_LEFT));break;\n          default: ;\n      }\n  }  \n}\n\n")),(0,o.kt)("p",null,"If you rotate in one direction and the keycodes are for the other direction, simply change the ",(0,o.kt)("inlineCode",{parentName:"p"},"if ( step > 0 )")," statement to ",(0,o.kt)("inlineCode",{parentName:"p"},"if ( step < 0 )")," or swap the keycodes around."),(0,o.kt)("p",null,"You can change the rotary encoder callback to a different function by calling a macro.  This will enable changing the behavior of the rotary encoder at runtime."),(0,o.kt)("h3",{id:"rotary-encoder-definition-up-to-8-encoders"},"Rotary Encoder Definition (Up to 8 encoders)"),(0,o.kt)("p",null,"You can refer to the configuration of the miniMACRO5 keyboard - default configuration for a working example for 5 encoders."),(0,o.kt)("p",null," This configuration uses the software interrupts and uses callbacks to handle rotation.  This limit on the number of encoders supported using software interrupts can be modified in the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/jpconstantineau/Adafruit_nRF52_Arduino/blob/master/libraries/RotaryEncoder/SwRotaryEncoder.cpp"},"library"),".  The Community BSP has a limit of 8 encoders while the adafruit BSP is set to a maximum of 4."),(0,o.kt)("p",null,"You will need to add a few things to your keymap.h file.  The example below is from the miniMACRO5 which supports up to 5 encoders."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c++"},'#include "KeyScanner.h"  // include at the top with the other includes\nextern DynamicState keyboardstate;\nvoid encoder_callback1(int step);\nvoid encoder_callback2(int step);\nvoid encoder_callback3(int step);\nvoid encoder_callback4(int step);\nvoid encoder_callback5(int step);\n\n')),(0,o.kt)("p",null,"You need to instantiate the software encoders in your keymap.cpp.  Add the following before your ",(0,o.kt)("inlineCode",{parentName:"p"},"setupKeymap()")," function:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c++"},"SwRotaryEncoder RotaryEncoder1,RotaryEncoder2, RotaryEncoder3, RotaryEncoder4, RotaryEncoder5;\n\n")),(0,o.kt)("p",null,"You will also need to add a few things to your keymap.cpp file.  For example, you will need to add the following lines in the ",(0,o.kt)("inlineCode",{parentName:"p"},"setupKeymap()")," function:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c++"},"byte encoder_pins_a[] ENCODER_PAD_A;\nbyte encoder_pins_b[] ENCODER_PAD_B;\n// Code below makes sure that the encoder gets configured.\n\n  RotaryEncoder1.begin(encoder_pins_a[0], encoder_pins_b[0]);    // Initialize Encoder\n  RotaryEncoder1.setCallback(encoder_callback1);    // Set callback\n\n  RotaryEncoder2.begin(encoder_pins_a[1], encoder_pins_b[1]);    // Initialize Encoder\n  RotaryEncoder2.setCallback(encoder_callback2);    // Set callback\n\n  RotaryEncoder3.begin(encoder_pins_a[2], encoder_pins_b[2]);    // Initialize Encoder\n  RotaryEncoder3.setCallback(encoder_callback3);    // Set callback\n\n  RotaryEncoder4.begin(encoder_pins_a[3], encoder_pins_b[3]);    // Initialize Encoder\n  RotaryEncoder4.setCallback(encoder_callback4);    // Set callback\n\n#ifdef ARDUINO_NRF52_COMMUNITY  // if you want to initialize more than 4, you need to compile on the Community BSP\n    RotaryEncoder5.begin(encoder_pins_a[4], encoder_pins_b[4]);    // Initialize Encoder\n  RotaryEncoder5.setCallback(encoder_callback5);    // Set callback\n#endif\n\n")),(0,o.kt)("p",null,"You will need to add the  ",(0,o.kt)("inlineCode",{parentName:"p"},"encoder_callback()")," functions (one per encoder):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c++"},"\nvoid encoder_callback1(int step)\n{\n  keyboardstate.encoder1pos = keyboardstate.encoder1pos + step; \n\n  if (abs(keyboardstate.encoder1pos) > ENCODER_RESOLUTION)\n  {\n    if ( keyboardstate.encoder1pos < 0  )\n    {\n      KeyScanner::add_to_encoderKeys(KC_AUDIO_VOL_UP); \n    }\n    else \n    {\n      KeyScanner::add_to_encoderKeys(KC_AUDIO_VOL_DOWN); \n    } \n    keyboardstate.encoder1pos = 0; \n  } \n}\n\nvoid encoder_callback2(int step)\n{\n  keyboardstate.encoder2pos = keyboardstate.encoder2pos + step; \n\n  if (abs(keyboardstate.encoder2pos) > ENCODER_RESOLUTION)\n  {\n    if ( keyboardstate.encoder2pos < 0  )\n    {\n  \n      KeyScanner::add_to_encoderKeys(KC_RIGHT); \n    }\n    else \n    {\n      KeyScanner::add_to_encoderKeys(KC_LEFT);\n    } \n    keyboardstate.encoder2pos = 0; \n  } \n}\n\nvoid encoder_callback3(int step)\n{\n  keyboardstate.encoder3pos = keyboardstate.encoder3pos + step; \n\n  if (abs(keyboardstate.encoder3pos) > ENCODER_RESOLUTION)\n  {\n    if ( keyboardstate.encoder3pos < 0  )\n    {\n  \n      KeyScanner::add_to_encoderKeys(KC_L); \n    }\n    else \n    {\n      KeyScanner::add_to_encoderKeys(KC_J);\n    } \n    keyboardstate.encoder3pos = 0; \n  } \n}\n\nvoid encoder_callback4(int step)\n{\n  keyboardstate.encoder4pos = keyboardstate.encoder4pos + step; \n\n  if (abs(keyboardstate.encoder4pos) > ENCODER_RESOLUTION)\n  {\n    if ( keyboardstate.encoder4pos < 0  )\n    {\n  \n      KeyScanner::add_to_encoderKeys(KC_COMMA); \n    }\n    else \n    {\n      KeyScanner::add_to_encoderKeys(KC_DOT);\n    } \n    keyboardstate.encoder4pos = 0; \n  } \n}\n\nvoid encoder_callback5(int step)\n{\n  keyboardstate.encoder5pos = keyboardstate.encoder5pos + step; \n\n  if (abs(keyboardstate.encoder5pos) > ENCODER_RESOLUTION)\n  {\n    if ( keyboardstate.encoder5pos < 0  )\n    {\n  \n      KeyScanner::add_to_encoderKeys(KC_UP); \n    }\n    else \n    {\n      KeyScanner::add_to_encoderKeys(KC_DOWN);\n    } \n    keyboardstate.encoder5pos = 0; \n  } \n}\n\n")),(0,o.kt)("p",null,"If you rotate in one direction and the keycodes are for the other direction, simply change the ",(0,o.kt)("inlineCode",{parentName:"p"},"if ( step > 0 )")," statement to ",(0,o.kt)("inlineCode",{parentName:"p"},"if ( step < 0 )")," or swap the keycodes around."),(0,o.kt)("p",null,"You can change the rotary encoder callback to a different function by calling a macro.  This will enable changing the behavior of the rotary encoder at runtime."),(0,o.kt)("h3",{id:"oled-definition"},"OLED Definition"),(0,o.kt)("p",null,"The default screens can be overriden by assigning a new callback."),(0,o.kt)("p",null,"You will need to add a few things to your keymap.h file."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c++"},'#include "BlueMicro_display.h"\n\n#ifdef BLUEMICRO_CONFIGURED_DISPLAY\nextern BlueMicro_Display OLED;        // needed to assign the update display callback\nextern DISPLAY_U8G2_CONSTRUCTOR u8g2; // needed to call the display functions\n#endif\n\nvoid updateDisplay(PersistentState* cfg, DynamicState* stat);\n\n')),(0,o.kt)("p",null,"You will also need to add a few things to your keymap.cpp file.  For example, you will need to add the following 3 lines in the ",(0,o.kt)("inlineCode",{parentName:"p"},"setupKeymap()")," function:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c++"},"\n    #ifdef BLUEMICRO_CONFIGURED_DISPLAY\n    OLED.setStatusDisplayCallback(updateDisplay);\n    #endif\n\n")),(0,o.kt)("p",null,"You will then need to define the ",(0,o.kt)("inlineCode",{parentName:"p"},"updateDisplay()")," function with your own requirements.  The following is an example that provides a battery icon, the computer or half it is connected to and the currently active layer. "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c++"},'void updateDisplay(PersistentState* cfg, DynamicState* stat)\n{\n    #ifdef BLUEMICRO_CONFIGURED_DISPLAY\n    u8g2.setFontMode(1);    // Transparent\n    u8g2.setFontDirection(0);\n    battery(22,19,stat->vbat_per);\n    printline(0,28,stat->peer_name_prph);\n\n    char buffer [50];\n    u8g2.setFont(u8g2_font_helvB12_tf); // choose a suitable font\n    switch(stat->layer)\n    {\n        case _QWERTY:     u8g2.drawStr(0,128,""); break;\n        case _LOWER:      u8g2.drawStr(0,128,"L");break;\n        case _RAISE:     u8g2.drawStr(0,128,"R");break;\n        case _ADJUST:     u8g2.drawStr(0,128,"A");break;\n        case _EXTRAL:     u8g2.drawStr(0,128,"EL");break;\n        case _EXTRAR:     u8g2.drawStr(0,128,"ER");break; \n        case _MACROL:     u8g2.drawStr(0,128,"ML");break;\n        case _MACROR:     u8g2.drawStr(0,128,"MR");break; \n        case _MACRO:     u8g2.drawStr(0,128,"M");break;    \n    }\n    #endif\n}\n')),(0,o.kt)("h3",{id:"speakerbuzzeraudio-definition"},"Speaker/Buzzer/Audio Definition"),(0,o.kt)("p",null,"If you want to add additional audio feedback to your macros or user functions, you will need to add a few lines to your keymap.h file:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c++"},'#define ENABLE_AUDIO\n#include "BlueMicro_tone.h"\nextern BlueMicro_tone speaker; \n')),(0,o.kt)("p",null,"Refer to the Luddite, default keymap for an example how to add music to your macros."))}u.isMDXComponent=!0}}]);